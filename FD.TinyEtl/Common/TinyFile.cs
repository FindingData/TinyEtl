///////////////////////////////////////////////////////////
//  TinyFile.cs
//  Implementation of the Class TinyFile
//  Generated by Enterprise Architect
//  Created on:      06-5ÔÂ-2018 18:56:00
//  Original author: drago
///////////////////////////////////////////////////////////

using System;
using System.Collections.Generic;
using System.Text;
using System.IO;
using System.Linq;



namespace FD.TinyEtl {
	public static class TinyFile {
        public static Encoding GetEncodingFromFile(string fileName)
        {
            // Read the BOM
            var bom = new byte[4];
            using (var file = new FileStream(fileName, FileMode.Open, FileAccess.Read))
            {
                return GetEncodingFromStream(file);
            }
        }

        public static Encoding GetEncodingFromStream(Stream file)
        {
            // Read the BOM
            var bom = new byte[4];
            file.Seek(0, SeekOrigin.Begin);

            file.Read(bom, 0, 4);
            // Analyze the BOM
            if (bom[0] == 0x2b && bom[1] == 0x2f && bom[2] == 0x76) return Encoding.UTF7;
            if (bom[0] == 0xef && bom[1] == 0xbb && bom[2] == 0xbf) return Encoding.UTF8;
            if (bom[0] == 0xff && bom[1] == 0xfe) return Encoding.Unicode; //UTF-16LE
            if (bom[0] == 0xfe && bom[1] == 0xff) return Encoding.BigEndianUnicode; //UTF-16BE
            if (bom[0] == 0 && bom[1] == 0 && bom[2] == 0xfe && bom[3] == 0xff) return Encoding.UTF32;
            return Encoding.Default;
        }

        public static IEnumerable<string> GetNextSequencedFileNameLike(string filePath, int startIndex = 1, int step = 1, int width = 5, string Separator = "_")
        {
            TinyGuard.ArgumentNotNullOrEmpty(filePath, "FilePath");
            if (startIndex <= 0)
                throw new ArgumentException("StartIndex must be > 0.");
            if (step <= 0)
                throw new ArgumentException("Step must be > 0");
            if (width <= 0)
                throw new ArgumentException("Width must be > 0");

            string dir = Path.GetDirectoryName(filePath);
            string fnWithoutExt = Path.GetFileNameWithoutExtension(filePath);
            string ext = Path.GetExtension(filePath);
            string format = $"D{width}";

            while (true)
            {
                yield return Path.Combine(dir, $"{fnWithoutExt}{Separator}{startIndex.ToString(format)}{ext}");
                startIndex += step;
            }
        }

        public static string PostFix(string filePath, string postFix)
        {
            TinyGuard.ArgumentNotNullOrEmpty(filePath, "FilePath");
            TinyGuard.ArgumentNotNullOrEmpty(postFix, "PostFix");

            string dir = Path.GetDirectoryName(filePath);
            string fnWithoutExt = Path.GetFileNameWithoutExtension(filePath);
            string ext = Path.GetExtension(filePath);

            return Path.Combine(dir, $"{fnWithoutExt}{postFix}{ext}");
        }

        public static string PreFix(string filePath, string preFix)
        {
            TinyGuard.ArgumentNotNullOrEmpty(filePath, "FilePath");
            TinyGuard.ArgumentNotNullOrEmpty(preFix, "PreFix");

            string dir = Path.GetDirectoryName(filePath);
            string fnWithoutExt = Path.GetFileNameWithoutExtension(filePath);
            string ext = Path.GetExtension(filePath);

            return Path.Combine(dir, $"{preFix}{fnWithoutExt}{ext}");
        }

        public static void AppendFileTo(string srcFilePath, string destFilePath, int bufferSize = 4096)
        {
            TinyGuard.ArgumentNotNullOrEmpty(srcFilePath, "srcFilePath");
            TinyGuard.ArgumentNotNullOrEmpty(destFilePath, "destFilePath");

            using (var outputStream = File.OpenWrite(destFilePath))
            {
                using (var inputStream = File.OpenRead(srcFilePath))
                {
                    // Buffer size can be passed as the second argument.
                    inputStream.CopyTo(outputStream, bufferSize);
                }
            }
        }

        public static void CombineFiles(string srcFilePathPattern, string destFilePath, int bufferSize = 4096, string EOFDelimiter = null)
        {
            TinyGuard.ArgumentNotNullOrEmpty(srcFilePathPattern, "srcFilePathPattern");
            TinyGuard.ArgumentNotNullOrEmpty(destFilePath, "destFilePath");

            if (EOFDelimiter == null)
                EOFDelimiter = Environment.NewLine;

            using (var outputStream = File.OpenWrite(destFilePath))
            {
                foreach (string fp in TinyDirectory.GetFilesBeginWith(srcFilePathPattern).OrderBy(f => f, StringComparer.CurrentCultureIgnoreCase))
                {
                    if (new FileInfo(fp).Length == 0) continue;
                    using (var inputStream = File.OpenRead(fp))
                    {
                        if (outputStream.Position != 0)
                            outputStream.Write(EOFDelimiter);

                        // Buffer size can be passed as the second argument.
                        inputStream.CopyTo(outputStream, bufferSize);
                    }
                }
            }
        }

        public static void DeleteAll(string srcFilePathPattern)
        {
            TinyGuard.ArgumentNotNullOrEmpty(srcFilePathPattern, "srcFilePathPattern");

            foreach (string fp in TinyDirectory.GetFilesBeginWith(srcFilePathPattern).OrderBy(f => f, StringComparer.CurrentCultureIgnoreCase))
            {
                File.Delete(fp);
            }
        }

        public static void Move(string srcFilePath, string destFilePath)
        {
            TinyGuard.ArgumentNotNullOrEmpty(srcFilePath, "SrcFilePath");
            TinyGuard.ArgumentNotNullOrEmpty(destFilePath, "destFilePath");

            if (File.Exists(destFilePath))
                File.Delete(destFilePath);

            File.Move(srcFilePath, destFilePath);
        }

        public static string ReadAllText(string filePath)
        {
            TinyGuard.ArgumentNotNullOrEmpty(filePath, "FilePath");
            filePath = TinyPath.GetFullPath(filePath);

            if (File.Exists(filePath))
                return File.ReadAllText(filePath);
            else
            {
                try
                {
                    File.CreateText(filePath);
                }
                catch { }
                return String.Empty;
            }
        }

        public static string[] ReadAllLines(string filePath)
        {
            TinyGuard.ArgumentNotNullOrEmpty(filePath, "FilePath");
            filePath = TinyPath.GetFullPath(filePath);

            if (File.Exists(filePath))
                return File.ReadAllLines(filePath);
            else
            {
                try
                {
                    File.CreateText(filePath);
                }
                catch { }
                return new string[] { };
            }
        }
    }//end TinyFile

}//end namespace FD.TinyEtl